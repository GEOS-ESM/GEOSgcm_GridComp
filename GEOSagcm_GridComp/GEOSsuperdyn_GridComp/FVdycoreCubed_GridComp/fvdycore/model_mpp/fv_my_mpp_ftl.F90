module     g_fv_my_mpp
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fv_mp_mod, only : domain

use mpp_domains_mod,  only: CGRID_NE, DGRID_NE, mpp_get_boundary,   &
                                mpp_update_domains
use fv_my_mpp

  public g_mpp_update_domains_dummy
  public g_mpp_update_domains_CGRID,g_mpp_update_domains_DGRID
  public g_mpp_get_boundary_DGRID

!==============================================
! all entries are defined explicitly
!==============================================


!==============================================
! generic interface blocks
!==============================================
interface g_mpp_update_domains_dummy
  module procedure g_mpp_update_domains_dummy1
  module procedure g_mpp_update_domains_dummy2
  module procedure g_mpp_update_domains_dummy3
end interface
interface g_mpp_get_boundary_dummy
  module procedure g_mpp_get_boundary_dummy2
end interface
interface g_mp_reduce_max_dummy
  module procedure g_mp_reduce_max_dummy1
  module procedure g_mp_reduce_max_dummy2
end interface

contains
subroutine g_mp_reduce_max_dummy1( cmax, g_cmax )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real :: cmax
real :: g_cmax

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
!g_cmax = 1.*g_cmax
!cmax = 1.*cmax

end subroutine g_mp_reduce_max_dummy1


subroutine g_mp_reduce_max_dummy2( cmax, g_cmax, npz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: npz
real :: cmax(npz)
real :: g_cmax(npz)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
!g_cmax(:) = 1.*g_cmax(:)
!cmax(:) = 1.*cmax(:)

end subroutine g_mp_reduce_max_dummy2
subroutine g_mpp_update_domains_dummy1( field, g_field, is, ie, js, je, isd, ied, jsd, jed, km )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied
integer :: isd
integer :: jed
integer :: jsd
integer :: km
real :: field(isd:ied,jsd:jed,km)
real :: g_field(isd:ied,jsd:jed,km)
integer :: ie
integer :: is
integer :: je
integer :: js

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k

      call mpp_update_domains(  field, domain, complete=.true.)
      call mpp_update_domains(  g_field, domain, complete=.true.)
!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
! do k = 1, km
!   g_field_temp = g_field(is,js,k)
!   field_temp = field(is,js,k)
!   g_field(isd:is-1,:,k) = g_field_temp
!   field(isd:is-1,:,k) = field_temp
!   g_field(:,jsd:js-1,k) = g_field_temp
!   field(:,jsd:js-1,k) = field_temp
!   g_field_temp = g_field(ie,je,k)
!   field_temp = field(ie,je,k)
!   g_field(ie+1:ied,:,k) = g_field_temp
!   field(ie+1:ied,:,k) = field_temp
!   g_field(:,je+1:jed,k) = g_field_temp
!   field(:,je+1:jed,k) = field_temp
! end do

end subroutine g_mpp_update_domains_dummy1


subroutine g_mpp_update_domains_dummy2( field1, g_field1, field2, g_field2, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, is2, &
&ie2, js2, je2, isd2, ied2, jsd2, jed2, km2)!, my_flag )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: field1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: field2(isd2:ied2,jsd2:jed2,km2)
real :: g_field1(isd1:ied1,jsd1:jed1,km1)
real :: g_field2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k, my_flag

!if (my_flag.eq.1) call mpp_update_domains(field2,field1, domain, gridtype=CGRID_NE, complete=.true.)
!if (my_flag.eq.1) call mpp_update_domains(g_field2,g_field1, domain, gridtype=CGRID_NE, complete=.true.)
!if (my_flag.eq.2) call mpp_update_domains(field1,field2, domain, gridtype=DGRID_NE) 
!if (my_flag.eq.2) call mpp_update_domains(g_field1,g_field2, domain, gridtype=DGRID_NE)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, km2
  g_field_temp = g_field2(is2,js2,k)
  field_temp = field2(is2,js2,k)
  g_field2(isd2:is2-1,:,k) = g_field_temp
  field2(isd2:is2-1,:,k) = field_temp
  g_field2(:,jsd2:js2-1,k) = g_field_temp
  field2(:,jsd2:js2-1,k) = field_temp
  g_field_temp = g_field2(ie2,je2,k)
  field_temp = field2(ie2,je2,k)
  g_field2(ie2+1:ied2-1,:,k) = g_field_temp
  field2(ie2+1:ied2-1,:,k) = field_temp
  g_field2(:,je2+1:jed2,k) = g_field_temp
  field2(:,je2+1:jed2,k) = field_temp
end do
do k = 1, km1
  g_field_temp = g_field1(is1,js1,k)
  field_temp = field1(is1,js1,k)
  g_field1(isd1:is1-1,:,k) = g_field_temp
  field1(isd1:is1-1,:,k) = field_temp
  g_field1(:,jsd1:js1-1,k) = g_field_temp
  field1(:,jsd1:js1-1,k) = field_temp
  g_field_temp = g_field1(ie1,je1,k)
  field_temp = field1(ie1,je1,k)
  g_field1(ie1+1:ied1,:,k) = g_field_temp
  field1(ie1+1:ied1,:,k) = field_temp
  g_field1(:,je1+1:jed1-1,k) = g_field_temp
  field1(:,je1+1:jed1-1,k) = field_temp
end do

end subroutine g_mpp_update_domains_dummy2

subroutine g_mpp_update_domains_CGRID( field1, g_field1, field2, g_field2, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, is2, &
&ie2, js2, je2, isd2, ied2, jsd2, jed2, km2)
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: field1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: field2(isd2:ied2,jsd2:jed2,km2)
real :: g_field1(isd1:ied1,jsd1:jed1,km1)
real :: g_field2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k, my_flag

call mpp_update_domains(field2,field1, domain, gridtype=CGRID_NE, complete=.true.)
call mpp_update_domains(g_field2,g_field1, domain, gridtype=CGRID_NE, complete=.true.)


end subroutine g_mpp_update_domains_CGRID

subroutine g_mpp_update_domains_DGRID( field1, g_field1, field2, g_field2, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, is2, &
&ie2, js2, je2, isd2, ied2, jsd2, jed2, km2)
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: field1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: field2(isd2:ied2,jsd2:jed2,km2)
real :: g_field1(isd1:ied1,jsd1:jed1,km1)
real :: g_field2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k, my_flag

call mpp_update_domains(field1,field2, domain, gridtype=DGRID_NE) 
call mpp_update_domains(g_field1,g_field2, domain, gridtype=DGRID_NE)


end subroutine g_mpp_update_domains_DGRID

subroutine g_mpp_get_boundary_DGRID( field1, g_field1, field2, g_field2, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, is2, &
&ie2, js2, je2, isd2, ied2, jsd2, jed2, km2,npx,npy,npz,is,ie,js,je)
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: field1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: field2(isd2:ied2,jsd2:jed2,km2)
real :: g_field1(isd1:ied1,jsd1:jed1,km1)
real :: g_field2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k, my_flag
  integer :: npx,npy,npz,is,ie,js,je
real :: wbuffer(npy+2,npz)
real :: sbuffer(npx+2,npz)

  wbuffer=0
  sbuffer=0
call mpp_get_boundary(field1,field2,domain,wbuffery=wbuffer,&
                      ebuffery=field2(ie+1,js:je,1:npz),&
                                           sbufferx=sbuffer,&
                      nbufferx=field1(is:ie,je+1,1:npz),gridtype=DGRID_NE )

  wbuffer=0
  sbuffer=0
call mpp_get_boundary(g_field1,g_field2,domain,wbuffery=wbuffer,&
                      ebuffery=g_field2(ie+1,js:je,1:npz),&
                                           sbufferx=sbuffer,&
                      nbufferx=g_field1(is:ie,je+1,1:npz),gridtype=DGRID_NE )


end subroutine g_mpp_get_boundary_DGRID

subroutine g_mpp_get_boundary_dummy2( field1, g_field1, field2, g_field2, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, is2, &
&ie2, js2, je2, isd2, ied2, jsd2, jed2, km2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: field1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: field2(isd2:ied2,jsd2:jed2,km2)
real :: g_field1(isd1:ied1,jsd1:jed1,km1)
real :: g_field2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do k = 1, km2
  g_field_temp = g_field2(is2,js2,k)
  field_temp = field2(is2,js2,k)
  g_field2(isd2:is2-1,:,k) = g_field_temp
  field2(isd2:is2-1,:,k) = field_temp
  g_field2(:,jsd2:js2-1,k) = g_field_temp
  field2(:,jsd2:js2-1,k) = field_temp
  g_field_temp = g_field2(ie2,je2,k)
  field_temp = field2(ie2,je2,k)
  g_field2(ie2+1:ied2-1,:,k) = g_field_temp
  field2(ie2+1:ied2-1,:,k) = field_temp
  g_field2(:,je2+1:jed2,k) = g_field_temp
  field2(:,je2+1:jed2,k) = field_temp
end do
do k = 1, km1
  g_field_temp = g_field1(is1,js1,k)
  field_temp = field1(is1,js1,k)
  g_field1(isd1:is1-1,:,k) = g_field_temp
  field1(isd1:is1-1,:,k) = field_temp
  g_field1(:,jsd1:js1-1,k) = g_field_temp
  field1(:,jsd1:js1-1,k) = field_temp
  g_field_temp = g_field1(ie1,je1,k)
  field_temp = field1(ie1,je1,k)
  g_field1(ie1+1:ied1,:,k) = g_field_temp
  field1(ie1+1:ied1,:,k) = field_temp
  g_field1(:,je1+1:jed1-1,k) = g_field_temp
  field1(:,je1+1:jed1-1,k) = field_temp
end do

end subroutine g_mpp_get_boundary_dummy2

subroutine g_mpp_update_domains_dummy3( field1, g_field1, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, nq )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
integer :: nq
real :: field1(isd1:ied1,jsd1:jed1,km1,nq)
real :: g_field1(isd1:ied1,jsd1:jed1,km1,nq)
integer :: ie1
integer :: is1
integer :: je1
integer :: js1

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k
integer :: m

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do m = 1, nq
  do k = 1, km1
    g_field_temp = g_field1(is1,js1,k,m)
    field_temp = field1(is1,js1,k,m)
    g_field1(isd1:is1-1,:,k,m) = g_field_temp
    field1(isd1:is1-1,:,k,m) = field_temp
    g_field1(:,jsd1:js1-1,k,m) = g_field_temp
    field1(:,jsd1:js1-1,k,m) = field_temp
    g_field_temp = g_field1(ie1,je1,k,m)
    field_temp = field1(ie1,je1,k,m)
    g_field1(ie1+1:ied1,:,k,m) = g_field_temp
    field1(ie1+1:ied1,:,k,m) = field_temp
    g_field1(:,je1+1:jed1-1,k,m) = g_field_temp
    field1(:,je1+1:jed1-1,k,m) = field_temp
  end do
end do

end subroutine g_mpp_update_domains_dummy3
subroutine g_mpp_update_domains_dummy4( field1, g_field1, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, nq )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
integer :: nq
real :: field1(isd1:ied1,jsd1:jed1,km1,nq)
real :: g_field1(isd1:ied1,jsd1:jed1,km1,nq)
integer :: ie1
integer :: is1
integer :: je1
integer :: js1

!==============================================
! declare local variables
!==============================================
real :: field_temp
real :: g_field_temp
integer :: k
integer :: m

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do m = 1, nq
      call mpp_update_domains(  field1(:,:,:,m), domain, complete=.true.)
      call mpp_update_domains(  g_field1(:,:,:,m), domain, complete=.true.)
!  do k = 1, km1
!    g_field_temp = g_field1(is1,js1,k,m)
!    field_temp = field1(is1,js1,k,m)
!    g_field1(isd1:is1-1,:,k,m) = g_field_temp
!    field1(isd1:is1-1,:,k,m) = field_temp
!    g_field1(:,jsd1:js1-1,k,m) = g_field_temp
!    field1(:,jsd1:js1-1,k,m) = field_temp
!    g_field_temp = g_field1(ie1,je1,k,m)
!    field_temp = field1(ie1,je1,k,m)
!    g_field1(ie1+1:ied1,:,k,m) = g_field_temp
!    field1(ie1+1:ied1,:,k,m) = field_temp
!    g_field1(:,je1+1:jed1-1,k,m) = g_field_temp
!    field1(:,je1+1:jed1-1,k,m) = field_temp
!  end do
end do

end subroutine g_mpp_update_domains_dummy4

end module     g_fv_my_mpp



