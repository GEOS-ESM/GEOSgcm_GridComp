module     adfv_my_mpp
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use fv_mp_mod, only : domain

use mpp_domains_mod, only : mpp_update_domains_ad

use mpp_domains_mod,  only: CGRID_NE, DGRID_NE, mpp_get_boundary,   &
                                mpp_update_domains, mpp_get_boundary_ad

use fv_my_mpp

  public admpp_update_domains_dummy, admpp_update_domains_dummy4
  public admpp_update_domains_CGRID, admpp_update_domains_DGRID
  public admpp_get_boundary_DGRID

!==============================================
! all entries are defined explicitly
!==============================================

!==============================================
! generic interface blocks
!==============================================
interface admpp_update_domains_dummy
  module procedure admpp_update_domains_dummy1
  module procedure admpp_update_domains_dummy2
  module procedure admpp_update_domains_dummy3
end interface

interface admpp_get_boundary_dummy
  module procedure admpp_get_boundary_dummy2
end interface

interface admp_reduce_max_dummy
  module procedure admp_reduce_max_dummy1
  module procedure admp_reduce_max_dummy2
end interface

contains
subroutine admp_reduce_max_dummy1( adcmax )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real :: adcmax

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
!adcmax = adcmax

end subroutine admp_reduce_max_dummy1


subroutine admp_reduce_max_dummy2( adcmax, npz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: npz
real :: adcmax(npz)

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
!adcmax(:) = adcmax(:)

end subroutine admp_reduce_max_dummy2

subroutine admpp_update_domains_dummy1( adfield, is, ie, js, je, isd, ied, jsd, jed, km )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied
integer :: isd
integer :: jed
integer :: jsd
integer :: km
real :: adfield(isd:ied,jsd:jed,km)
integer :: ie
integer :: is
integer :: je
integer :: js

!==============================================
! declare local variables
!==============================================
real :: adfield_temp
integer :: k

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
    call mpp_update_domains_ad(  adfield, domain, complete=.true.)

! adfield_temp = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
! do k = 1, km
!   adfield_temp = 0.
!   adfield_temp = adfield_temp+sum(adfield(:,je+1:jed,k))
!   adfield(:,je+1:jed,k) = 0.
!   adfield_temp = adfield_temp+sum(adfield(ie+1:ied,:,k))
!   adfield(ie+1:ied,:,k) = 0.
!   adfield(ie,je,k) = adfield(ie,je,k)+adfield_temp
!   adfield_temp = 0.
!   adfield_temp = adfield_temp+sum(adfield(:,jsd:js-1,k))
!   adfield(:,jsd:js-1,k) = 0.
!   adfield_temp = adfield_temp+sum(adfield(isd:is-1,:,k))
!   adfield(isd:is-1,:,k) = 0.
!   adfield(is,js,k) = adfield(is,js,k)+adfield_temp
!   adfield_temp = 0.
! end do

end subroutine admpp_update_domains_dummy1


subroutine admpp_update_domains_dummy2( adfield1, adfield2, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, is2, ie2, js2, je2, &
&isd2, ied2, jsd2, jed2, km2)!, my_flag )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.33  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: adfield1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: adfield2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: adfield_temp
integer :: k, my_flag
!if (my_flag.eq.1) call mpp_update_domains_ad(adfield2, adfield1, domain, gridtype=CGRID_NE, complete=.true.)
!if (my_flag.eq.2) call mpp_update_domains_ad(adfield1, adfield2, domain, gridtype=DGRID_NE)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adfield_temp = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do k = 1, km1
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield1(:,je1+1:jed1-1,k))
  adfield1(:,je1+1:jed1-1,k) = 0.
  adfield_temp = adfield_temp+sum(adfield1(ie1+1:ied1,:,k))
  adfield1(ie1+1:ied1,:,k) = 0.
  adfield1(ie1,je1,k) = adfield1(ie1,je1,k)+adfield_temp
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield1(:,jsd1:js1-1,k))
  adfield1(:,jsd1:js1-1,k) = 0.
  adfield_temp = adfield_temp+sum(adfield1(isd1:is1-1,:,k))
  adfield1(isd1:is1-1,:,k) = 0.
  adfield1(is1,js1,k) = adfield1(is1,js1,k)+adfield_temp
  adfield_temp = 0.
end do
do k = 1, km2
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield2(:,je2+1:jed2,k))
  adfield2(:,je2+1:jed2,k) = 0.
  adfield_temp = adfield_temp+sum(adfield2(ie2+1:ied2-1,:,k))
  adfield2(ie2+1:ied2-1,:,k) = 0.
  adfield2(ie2,je2,k) = adfield2(ie2,je2,k)+adfield_temp
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield2(:,jsd2:js2-1,k))
  adfield2(:,jsd2:js2-1,k) = 0.
  adfield_temp = adfield_temp+sum(adfield2(isd2:is2-1,:,k))
  adfield2(isd2:is2-1,:,k) = 0.
  adfield2(is2,js2,k) = adfield2(is2,js2,k)+adfield_temp
  adfield_temp = 0.
end do

end subroutine admpp_update_domains_dummy2
 subroutine admpp_update_domains_CGRID(adfield1,adfield2,&
                                      is1,ie1,js1,je1,isd1,ied1,jsd1,jed1,km1,&
                                      is2,ie2,js2,je2,isd2,ied2,jsd2,jed2,km2)

implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: adfield1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: adfield2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: adfield_temp
integer :: k, my_flag

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------

  call mpp_update_domains_ad(adfield2, adfield1, domain, gridtype=CGRID_NE, complete=.true.)

 end subroutine admpp_update_domains_CGRID

 subroutine admpp_update_domains_DGRID(adfield1,adfield2,&
                                      is1,ie1,js1,je1,isd1,ied1,jsd1,jed1,km1,&
                                      is2,ie2,js2,je2,isd2,ied2,jsd2,jed2,km2)

implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: adfield1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: adfield2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: adfield_temp
integer :: k, my_flag

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------

  call mpp_update_domains_ad(adfield1, adfield2, domain, gridtype=DGRID_NE)


 end subroutine admpp_update_domains_DGRID
 subroutine admpp_get_boundary_DGRID(field1,field2,&
                                     is1,ie1,js1,je1,isd1,ied1,jsd1,jed1,km1,&
                                     is2,ie2,js2,je2,isd2,ied2,jsd2,jed2,km2,&
                                     npx,npy,npz,is,ie,js,je)

  integer :: is1,ie1,js1,je1,isd1,ied1,jsd1,jed1,km1
  integer :: is2,ie2,js2,je2,isd2,ied2,jsd2,jed2,km2
  real :: field1(isd1:ied1,jsd1:jed1,km1)
  real :: field2(isd2:ied2,jsd2:jed2,km2)
  real :: field_temp
  integer :: npx,npy,npz,is,ie,js,je
  real :: wbuffer(npy+2,npz)
  real :: sbuffer(npx+2,npz)

  integer :: i,j,k,my_flag

  wbuffer=0
  sbuffer=0
  call mpp_get_boundary_ad(field1,field2,domain,wbuffery=wbuffer,&
                           ebuffery=field2(ie+1,js:je,1:npz),&
                                                sbufferx=sbuffer,&
                           nbufferx=field1(is:ie,je+1,1:npz),gridtype=DGRID_NE )

 end subroutine admpp_get_boundary_DGRID


subroutine admpp_get_boundary_dummy2( adfield1, adfield2, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, is2, ie2, js2, je2, &
&isd2, ied2, jsd2, jed2, km2 )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
real :: adfield1(isd1:ied1,jsd1:jed1,km1)
integer :: ied2
integer :: isd2
integer :: jed2
integer :: jsd2
integer :: km2
real :: adfield2(isd2:ied2,jsd2:jed2,km2)
integer :: ie1
integer :: ie2
integer :: is1
integer :: is2
integer :: je1
integer :: je2
integer :: js1
integer :: js2

!==============================================
! declare local variables
!==============================================
real :: adfield_temp
integer :: k

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adfield_temp = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do k = 1, km1
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield1(:,je1+1:jed1-1,k))
  adfield1(:,je1+1:jed1-1,k) = 0.
  adfield_temp = adfield_temp+sum(adfield1(ie1+1:ied1,:,k))
  adfield1(ie1+1:ied1,:,k) = 0.
  adfield1(ie1,je1,k) = adfield1(ie1,je1,k)+adfield_temp
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield1(:,jsd1:js1-1,k))
  adfield1(:,jsd1:js1-1,k) = 0.
  adfield_temp = adfield_temp+sum(adfield1(isd1:is1-1,:,k))
  adfield1(isd1:is1-1,:,k) = 0.
  adfield1(is1,js1,k) = adfield1(is1,js1,k)+adfield_temp
  adfield_temp = 0.
end do
do k = 1, km2
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield2(:,je2+1:jed2,k))
  adfield2(:,je2+1:jed2,k) = 0.
  adfield_temp = adfield_temp+sum(adfield2(ie2+1:ied2-1,:,k))
  adfield2(ie2+1:ied2-1,:,k) = 0.
  adfield2(ie2,je2,k) = adfield2(ie2,je2,k)+adfield_temp
  adfield_temp = 0.
  adfield_temp = adfield_temp+sum(adfield2(:,jsd2:js2-1,k))
  adfield2(:,jsd2:js2-1,k) = 0.
  adfield_temp = adfield_temp+sum(adfield2(isd2:is2-1,:,k))
  adfield2(isd2:is2-1,:,k) = 0.
  adfield2(is2,js2,k) = adfield2(is2,js2,k)+adfield_temp
  adfield_temp = 0.
end do

end subroutine admpp_get_boundary_dummy2

subroutine admpp_update_domains_dummy3( adfield1, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, nq )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
integer :: nq
real :: adfield1(isd1:ied1,jsd1:jed1,km1,nq)
integer :: ie1
integer :: is1
integer :: je1
integer :: js1

!==============================================
! declare local variables
!==============================================
real :: adfield_temp
integer :: k
integer :: m

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adfield_temp = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do m = 1, nq
  adfield_temp = 0.
  do k = 1, km1
    adfield_temp = 0.
    adfield_temp = adfield_temp+sum(adfield1(:,je1+1:jed1-1,k,m))
    adfield1(:,je1+1:jed1-1,k,m) = 0.
    adfield_temp = adfield_temp+sum(adfield1(ie1+1:ied1,:,k,m))
    adfield1(ie1+1:ied1,:,k,m) = 0.
    adfield1(ie1,je1,k,m) = adfield1(ie1,je1,k,m)+adfield_temp
    adfield_temp = 0.
    adfield_temp = adfield_temp+sum(adfield1(:,jsd1:js1-1,k,m))
    adfield1(:,jsd1:js1-1,k,m) = 0.
    adfield_temp = adfield_temp+sum(adfield1(isd1:is1-1,:,k,m))
    adfield1(isd1:is1-1,:,k,m) = 0.
    adfield1(is1,js1,k,m) = adfield1(is1,js1,k,m)+adfield_temp
    adfield_temp = 0.
  end do
end do

end subroutine admpp_update_domains_dummy3

subroutine admpp_update_domains_dummy4( adfield1, is1, ie1, js1, je1, isd1, ied1, jsd1, jed1, km1, nq )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.37  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer :: ied1
integer :: isd1
integer :: jed1
integer :: jsd1
integer :: km1
integer :: nq
real :: adfield1(isd1:ied1,jsd1:jed1,km1,nq)
integer :: ie1
integer :: is1
integer :: je1
integer :: js1

!==============================================
! declare local variables
!==============================================
real :: adfield_temp
integer :: k
integer :: m

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adfield_temp = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do m = 1, nq
    call mpp_update_domains_ad(  adfield1(:,:,:,m), domain, complete=.true.)
!  adfield_temp = 0.
!  do k = 1, km1
!    adfield_temp = 0.
!    adfield_temp = adfield_temp+sum(adfield1(:,je1+1:jed1-1,k,m))
!    adfield1(:,je1+1:jed1-1,k,m) = 0.
!    adfield_temp = adfield_temp+sum(adfield1(ie1+1:ied1,:,k,m))
!    adfield1(ie1+1:ied1,:,k,m) = 0.
!    adfield1(ie1,je1,k,m) = adfield1(ie1,je1,k,m)+adfield_temp
!    adfield_temp = 0.
!    adfield_temp = adfield_temp+sum(adfield1(:,jsd1:js1-1,k,m))
!    adfield1(:,jsd1:js1-1,k,m) = 0.
!    adfield_temp = adfield_temp+sum(adfield1(isd1:is1-1,:,k,m))
!    adfield1(isd1:is1-1,:,k,m) = 0.
!    adfield1(is1,js1,k,m) = adfield1(is1,js1,k,m)+adfield_temp
!    adfield_temp = 0.
!  end do
end do

end subroutine admpp_update_domains_dummy4

end module     adfv_my_mpp


