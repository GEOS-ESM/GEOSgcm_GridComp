#include "Raster.h"

PROGRAM mkEASETilesParam 
  
  ! This program constructs land and lake tiles for EASE grid tile spaces such as
  !  those used for the SMAP Level-4 products and other offline projects

  ! This program resulted from the merger and cleanup of mkSMAPTilesPara.F90
  !  and mkSMAPTilesPara_v2.F90 in September 2022.
  ! Before the merger and cleanup, the EASE grid parameters were hard-coded here.
  !  For EASEv2 M25, the outdated scale value was used here.
  ! The program was renamed to mkEASETileParam from mkSMAPTilesPara_v2
  !
  ! - wjiang + reichle, 21 Sep 2022
  

      use EASE_conv
      use rmTinyCatchParaMod, only : i_raster, j_raster, SRTM_maxcat 
      use rmTinyCatchParaMod, only : RegridRaster, RegridRaster1, RegridRasterReal
      use rmTinyCatchParaMod, only : MAKE_BCS_INPUT_DIR 
      use process_hres_data
      use MAPL_SortMod
      use MAPL_ConstantsMod
      use LogRectRasterizeMod
      use netcdf
      
      implicit none
      integer i,j,ig,jg,i0,iop,n,d1,d2,j1,j2,i1,i2,ix, jx,icount,pcount
      integer :: NC = i_raster, NR = j_raster, NT = 16330000, ND = 10000, ND_raster = 10000
      
      integer, parameter :: nc_esa = 129600, nr_esa = 64800

      ! For regridding

      integer, allocatable, target, dimension (:,:) &
                                          :: geos_msk 
      REAL,    allocatable, DIMENSION (:) :: loc_val
      INTEGER, ALLOCATABLE, DIMENSION (:) :: density, loc_int
      logical, dimension (:), allocatable :: unq_mask   
      integer, pointer  , dimension (:,:) :: subset
      integer, pointer    , dimension (:) :: subset1
      real,    pointer    , dimension (:) :: subset2
      integer :: dx_esa, dy_esa, NBINS, NPLUS

      integer*8, allocatable, dimension (:) ::  SRTM_catid
      real(kind=8),allocatable, dimension(:)::  SRTM_catid_r8

      integer,allocatable, dimension (:,:), target :: tileid_index,catid_index
      integer,allocatable, dimension (:,:)         :: catid, iaster
      integer,allocatable, dimension (:)           :: land_id,water_id,ice_id
      integer,allocatable, dimension (:)           :: my_land, all_id
      real, allocatable, dimension (:)             :: ease_grid_area,tile_area,SRTM_CatchArea 
      integer*1,allocatable, dimension (:,:)       :: veg, i2aster
      real*4, dimension (:,:), allocatable         :: q0,raster
      REAL, dimension (:), allocatable             :: tile_ele, tile_area_land  

      INTEGER*8 :: PFAF_CODE  
      integer l,imn,imx,jmn,jmx,mval,l_index,i_index,w_index,typ,pfaf,cindex
      integer :: LakeType, IceType, OceanType
      character(3) :: easegrid      
      real :: clat, clon, r_ease, s_ease, da
      real :: fr_gcm
      integer :: ind_col, ind_row, status, ncid, varid, nciv,nland_cells, DOM_INDX
      !REAL (kind=8), PARAMETER :: RADIUS=6378137.0,pi=3.14159265358979323846
      character*100 :: veg_class (12)
      character*200 :: gfile,gtopo30
      integer :: nc_ease,nr_ease, N_args, command_argument_count 
      REAL :: dx,dy,d2r,lats,mnx,mxx,mny,mxy,sum1,sum2,jgv, VDUM,pix_area
      character(40) :: arg, EASElabel_ 
      character(len=:), allocatable :: EASElabel 
      character*200 :: tmpstring, tmpstring1, tmpstring2	      
      logical :: regrid = .false.
      character*128          :: MaskFile
      logical                :: pfaf_til = .false.
      character*1            :: PF
      character(len=6)       :: EASE_Version
      character(len=10)      :: nc_string, nr_string
      character(128)         :: usage1, usage2

      call get_environment_variable ("MAKE_BCS_INPUT_DIR",MAKE_BCS_INPUT_DIR)

      ! --------------------------------------------------------------------------------------

      usage1 = 'USAGE : bin/mkEASETilesParam.x -ease_label EASELabel                  '
      usage2 = '        where EASELabel = *EASEv[x]_M[yy]*, x={1,2}, yy={01,03,09,25,36}'

      N_args = command_argument_count()

      if(N_args < 1) then
        print *,trim(usage1)
        print *,trim(usage2)
        stop
      end if

      i=0      
      do while ( i < N_args )

         i = i+1
         
         call get_command_argument(i,arg)
         
         if     ( trim(arg) == '-ease_label' ) then
            i = i+1
            call get_command_argument(i,EASELabel_)

         ! WY noted: this may be used in the future for irrigation tiles
         !elseif ( trim(arg) == '-pfaf_til' ) then
         !   i = i+1
         !   call get_command_argument(i,PF)
         !   if (PF == 'T') pfaf_til = .true.

         else ! stop for any other arguments
            print *,trim(usage1)
            print *,trim(usage2)
            stop
         endif
         
      end do
      
      ! WY note, remove this verification. There can be all combination
     ! if (MGRID /= 'M25' .and. EASE_version == 'EASEv1') then
     !    stop ("EASEv1 only supports M25")
     ! endif      
      
      ! Setting EASE Grid specifications
      ! --------------------------------

      EASElabel = trim(EASELabel_)

      call ease_extent(EASELabel, nc_ease, nr_ease )
      write(nc_string, '(i0)') nc_ease
      write(nr_string, '(i0)') nr_ease
      gfile = trim(EASElabel)//'_'//trim(nc_string)//'x'//trim(nr_string)

      if (index(EASELabel,'M03') /=0) then ! EASE  3 km grid
         regrid = .true.
         NC = 21600
         NR = 10800
         NT = 500000000
      endif
      if (index(EASELabel,'M03') /=0) then ! EASE  1 km grid
         regrid = .true.
         NC = 43200
         NR = 21600
         NT = 1500000000
      endif

      allocate(land_id    (1:NT))
      allocate(water_id   (1:NT))
      allocate(ice_id     (1:NT))

      land_id     =  0
      water_id    =  0
      ice_id      =  0             
      OceanType   =  0
      IceType     = 11
      LakeType    = 10

      ND        = 10*10**(nint(log10(1.*nr_ease)))
      
      !   Check for the 10 arc-sec MaskFile
      ! -----------------------------------
      
      call get_environment_variable ("MASKFILE"        ,MaskFile        )

      print *, 'Using MaskFile ', trim(MaskFile)
      
      !   This section was used to make Irrigated Tiles 
      !if(pfaf_til)  then

      !   nc = 43200  ! Number of rows in raster file
      !   nr = 21600
      !   call mkEASEv2Raster
         
      !else
      !   if((trim(MGRID) == 'M09').or.(trim(MGRID) == 'M36'))call write_tilfile 
      !endif
      
      if (index(MaskFile,'GEOS5_10arcsec_mask') /= 0) then         
         ! New ESA (Veg) + SRTM (catchments) based mask file
         ! is overlaid on the EASE grid
         ! -------------------------------------------------
         
         nc = 43200  ! Number of rows in raster file
         nr = 21600  ! Number of columns in raster file

         regrid = .true.
         dx_esa = nc_esa / nc ! x-dimension (or # of ESA columns within the raster grid cell)
         dy_esa = nr_esa / nr ! y-dimension (or # of ESA rows within the raster grid cell)

         allocate(tileid_index(1:nc,1:nr))
         allocate(SRTM_catid  (1:SRTM_maxcat+2))
         allocate(SRTM_catid_r8(1:SRTM_maxcat+2), source = 0.d0)
         allocate(catid_index (1:nc,1:nr))          
         allocate(veg         (1:nc,1:nr))
         allocate(geos_msk    (1:nc_esa,1:dy_esa))
         allocate(SRTM_CatchArea (1:SRTM_maxcat))

         OPEN (10, FILE = trim(MAKE_BCS_INPUT_DIR)//'/land/topo/v1/SRTM-TopoData/Pfafcatch-routing.dat', &
              FORM = 'FORMATTED',STATUS='OLD',ACTION='READ') 

         READ (10,*) I
         DO N = 1, I
            READ (10, '(i8,i15,4(1x,f9.4),1x,e10.3,4(1x,e9.3),I8,6(1x,f9.4))')    &
                 DOM_INDX,PFAF_CODE,VDUM,VDUM,VDUM,VDUM,VDUM,                     &
                 SRTM_CatchArea (N)
         END DO
         CLOSE (10, STATUS='KEEP')

         dx  = 360._8/nc
         dy  = 180._8/nr
         d2r = MAPL_PI_R8/180._8
         !da  = MAPL_radius*MAPL_radius*pi*pi*dx*dy/180./180./1000000.    
         
         tileid_index = 0        
         catid_index  = 0
         veg          = 0
         
         status    = NF90_OPEN (trim(MAKE_BCS_INPUT_DIR)//'/shared/mask/GEOS5_10arcsec_mask.nc', NF90_NOWRITE, ncid)
         status    = nf90_inq_varid(ncid, name='PfafID', varid=varid)
         status    = nf90_get_var(ncid, varid, SRTM_catid_r8, (/1/),(/SRTM_maxcat/))
         if(status /=0) then
            PRINT *, NF90_STRERROR(STATUS)
            print *, 'Problem with NF90_OPEN',trim(MaskFile)
         endif
         SRTM_catid = int8(SRTM_catid_r8)
         SRTM_catid (SRTM_maxcat + 1) = 190000000
         SRTM_catid (SRTM_maxcat + 2) = 200000000 
         i1 = 0  ! count # of 30-arcsec pixels
         status    = nf90_inq_varid(ncid, name='CatchIndex', varid=varid)
         do j=1,nr

            clat = -90. + float(j-1)*dy + dy/2.
            status  = NF90_GET_VAR (ncid, varid, geos_msk, (/1,(j-1)*dy_esa +1/),(/nc_esa,dy_esa/)) ! Read 10-arcsec rows that lie within the raster row 'j'  
            !status  = NF_GET_VARA_INT (ncid,4,(/1,(j-1)*dy_esa +1/),(/nc_esa,dy_esa/),geos_msk) ! Read 10-arcsec rows that lie within the raster row 'j'  
            
            if(status /=0) then
               PRINT *, NF90_STRERROR(STATUS)
               print *, 'Problem with NF_GET_VARA_INT',trim(MaskFile),status
            endif
            
            do i = 1,nc    

               clon = -180. + float(i-1)*dx + dx/2.

               if (associated (subset)) NULLIFY (subset)
               subset => geos_msk ((i-1)*dx_esa + 1 : i*dx_esa, 1:dy_esa) ! rectangular array contains ESA pixels that lie within the raster grid cell at i,j
               if(maxval (subset) > SRTM_maxcat) then
                  where (subset == 190000000) subset = SRTM_maxcat + 1
                  where (subset == 200000000) subset = SRTM_maxcat + 2
               endif
               
               if (maxval (subset) > 0) then ! check whether there are Non-ocean ESA pixels 
                  ! catID of the middle pixel

                  veg (i,j) = 1 ! veg is set to land

                  NPLUS = count(subset >= 1 .and. subset <= SRTM_maxcat + 2) ! Count non-ocean ESA pixels within  
                  allocate (loc_int (1:NPLUS))
                  allocate (unq_mask(1:NPLUS))
                  loc_int = pack(subset,mask = (subset >= 1 .and. subset <= SRTM_maxcat + 2)) ! loc_int contains catch_indices of non-ocean ESA pixels 
                  call MAPL_Sort (loc_int)
                  unq_mask = .true.
                  do n = 2,NPLUS 
                     unq_mask(n) = .not.(loc_int(n) == loc_int(n-1)) ! count number of unique numbers in loc_int for binning
                  end do
                  NBINS = count(unq_mask)

                  if (NBINS > 1) then
                     allocate(loc_val (1:NBINS))
                     allocate(density (1:NBINS))
                     loc_val = 1.*pack(loc_int,mask =unq_mask)                               ! loc_val contains available non-ocean catch_indices within the i,j grid cell,
                                                                                             ! Those numbers will be used as bin values
                     call histogram (dx_esa*dy_esa, NBINS, density, loc_val, real(subset))   ! density is the pixel count for each bin value
                     catid_index (i,j) = loc_val (maxloc(density,1))                         ! picks maximum density as the dominant catchment_index at i,j
                     deallocate (loc_val, density)
                  else
                     catid_index (i,j) = loc_int (1)
                  endif
                  deallocate (loc_int, unq_mask)

                  if(catid_index (i,j) == SRTM_maxcat + 1) veg (i,j) = LakeType
                  if(catid_index (i,j) == SRTM_maxcat + 2) veg (i,j) = IceType
                  if((catid_index(i,j) >= 1).and.(catid_index  (i,j) <=  SRTM_maxcat)) i1 = i1 + 1

                  ! count in if this is i,j pixel is a land, lake or ice within ind_col,ind_row EASE grid cell
                  
                  call EASE_convert(EASELabel, clat, clon, r_ease, s_ease)
                  
                  ind_col = nint(r_ease) + 1 
                  ind_row = nint(s_ease) + 1
                  
                  if((ind_row.ge.1).and.(veg(i,j).ne.OceanType).and.(ind_row.le.nr_ease)) then
                     l=  ind_row*ND +  ind_col
                     
                     if(veg(i,j)==LakeType) then 
                        water_id(l) = 1
                     else if(veg(i,j)==IceType) then
                        ice_id  (l) = 1
                     else
                        land_id (l) = 1
                     endif
                  endif
               endif
            end do
         enddo

         status    = NF90_CLOSE (ncid)  
         deallocate (geos_msk)

         print *,'Read ', trim (MaskFile) 
         print *,'Min and Max of tile indices:',minval(catid_index),maxval(catid_index)

      else
         
         ! Old IGBP (Veg) + HYDRO1k (catchments) based mask will
         ! Overlaid on EASE mask
         ! -----------------------------------------------------
         
         allocate(iaster      (i_raster,j_raster)) 
         allocate(i2aster     (i_raster,j_raster))         
         allocate(veg         (1:nc,1:nr))
         allocate(catid       (1:nc,1:nr))
         allocate(catid_index (1:nc,1:nr))          
         allocate(tileid_index(1:nc,1:nr))

         dx  = 360._8/nc
         dy  = 180._8/nr
         d2r = MAPL_PI_R8/180._8
         !da  = MAPL_radius*MAPL_radius*pi*pi*dx*dy/180./180./1000000.    
         
         tileid_index = 0        

         !  Simple Biosphere 2 Model Legend 
         !  Value Class Name 
         !  (ftp://edcftp.cr.usgs.gov/pub/data/glcc/globe/latlon/sib22_0.leg)
         !  the types vary 0-11 (array index minus 1) 
         
         veg_class(1)  = 'Ocean'
         veg_class(2)  = 'Broadleaf Evergreen Trees' 
         veg_class(3)  = 'Broadleaf Deciduous Trees' 
         veg_class(4)  = 'Broadleaf and Needleleaf Trees' 
         veg_class(5)  = 'Needleleaf Evergreen Trees' 
         veg_class(6)  = 'Needleleaf Deciduous Trees' 
         veg_class(7)  = 'Short Vegetation/C4 Grassland'
         veg_class(8)  = 'Shrubs with Bare Soil' 
         veg_class(9)  = 'Dwarf Trees and Shrubs' 
         veg_class(10) = 'Agriculture or C3 Grassland' 
         veg_class(11) = 'Water, Wetlands'
         veg_class(12) = 'Ice/Snow'
         
         ! reading SiB2 land cover classification data - the origin of the 
         ! 2.5'x2.5' vegetation raster file is global 1min IGBP data 
         ! (ftp://edcftp.cr.usgs.gov/pub/data/glcc/globe/latlon/sib22_0.leg)
         
         open (10,file=trim(MAKE_BCS_INPUT_DIR)//'/land/veg/pft/v1/sib22.5_v2.0.dat', &
              form='unformatted', &
              action='read', convert='big_endian',status='old')
         
         READ(10)i2aster
         
         close (10,status='keep')
         
         if(regrid) then
            call RegridRaster1 (i2aster,veg)
         else
            veg = i2aster
         endif
         
         deallocate (i2aster)
         
         !   reading 2.5'x2.5' global raster file of Pfafstetter Catchment IDs
         !   In this version, the dateline has been overlaid over the catchments those straddle 
         !   across. The numbers contain for
         !    1 global ocean catchment                : Pfafstetter ID 0
         !    36716 global land catchments            : Pfafstetter IDs 1000-5999900
         !    1 global inland water (lakes) catchment : Pfafstetter ID 6190000
         !    1 global ice catchment                  : Pfafstetter ID 6200000
         
         open (10,file= trim(MAKE_BCS_INPUT_DIR)//'/shared/mask/global.cat_id.catch.DL', form='formatted', &
              action='read', status='old')!
         
         do j=1,j_raster
            read(10,*)(iaster(i,j),i=1,i_raster)
         end do
         
         close (10,status='keep')
         
         if(regrid) then
            call RegridRaster(iaster,catid)
         else
            catid =  iaster
         endif
         
         print *,'Read global.cat_id.catch.DL' 
         print *,'Min and Max of Pfafstetter IDs:', minval(catid),maxval(catid)
         
         ! reading the 2.5'x2.5' global raster file of tile indices for the 
         !  above Pfafstetter Catchments
         !  1 global ocean catchment                : tile_index 36719
         !  36716 global land catchments            : tile_index 1-36716
         !  1 global inland water (lakes) catchment : tile_index 36717
         !  1 global ice catchment                  : tile_index 36718
         ! ------------------------------------------------------------
         
         open (10,file=trim(MAKE_BCS_INPUT_DIR)//'/land/topo/'  &
              //'PfafstatterDL.rst', form='unformatted',        &
              action='read',convert='little_endian', status='old')
         
         do j=1,j_raster
            read(10)(iaster(i,j),i=1,i_raster)
         end do
         
         close (10,status='keep')
         
         if(regrid) then
            call RegridRaster(iaster,catid_index)
         else
            catid_index =  iaster
         endif
         
         deallocate (iaster)
         
         print *,'Read PfafstatterDL.rst' 
         print *,'Min and Max of tile indices:',minval(catid_index),maxval(catid_index)
 
         ! While looping through the nc x nr grid (tile raster), this section counts # of  
         ! EASE grid cells that contain land, ice or water, seperately.
         ! Each EASE grid cell is assigned with an ID = ind_row*ND +  ind_col. 
         ! This is just the prelimiminery assessment in the process of assigning separate  
         !     tiles for land, water and ice fractions within the EASE Grid cell
         ! The program checks each nc x nr pixels whether there is a EASE grid cell underneath, and counts
         ! number of water, land and ice pixels as seen on veg raster.
         ! -----------------------------------------------------------------------------------------------
         
         
         do i = 1 ,nc
            
            clon = -180. + float(i-1)*dx + dx/2.
            
            do j =nr ,1 ,-1
               
               clat = -90. + float(j-1)*dy + dy/2.
               call EASE_convert(EASELabel, clat, clon, r_ease, s_ease)
               
               ind_col = nint(r_ease) + 1 
               ind_row = nint(s_ease) + 1
               
               if((ind_row.ge.1).and.(veg(i,j).ne.OceanType).and.(ind_row.le.nr_ease)) then
                  l=  ind_row*ND +  ind_col
                  
                  if(veg(i,j)==LakeType) then 
                     water_id(l) = 1
                  else if(veg(i,j)==IceType) then
                     ice_id  (l) = 1
                  else
                     land_id (l) = 1
                  endif
               endif
            end do
         end do

      endif
      
      ! Reading SRTM elevation data - to be consistent with AGCM
      ! --------------------------------------------------------     
      
      allocate(raster      (i_raster,j_raster))
      allocate(q0(nc,nr)) 
      
      gtopo30 = trim(MAKE_BCS_INPUT_DIR)//'/land/topo/v1/srtm30_withKMS_2.5x2.5min.data'
     
      open (10,file=trim(gtopo30),form='unformatted',status='old',convert='little_endian')
      read (10) raster
      close (10,status='keep') 
      
      if(regrid) then
         call RegridRasterReal(raster,q0)
      else
         q0 =  raster
      endif
      
      deallocate (raster)
      
      print *,'# of Land  pixels in EASE: ',sum (land_id)
      print *,'# of water pixels in EASE: ',sum (water_id)
      print *,'# of ice   pixels in EASE: ',sum (ice_id)

      l_index=0
      w_index=sum (land_id)
      i_index=sum (land_id) + sum (water_id)
      nland_cells = w_index


      allocate(tile_area (1:i_index + sum (ice_id)))
      allocate(ease_grid_area     (1:NT))
      allocate(tile_ele      (1:w_index))
      allocate(tile_area_land(1:w_index)) 
      allocate(my_land       (1:i_index + sum (ice_id)))
      allocate(all_id        (1:i_index + sum (ice_id)))

      land_id = 0
      water_id= 0
      ice_id  = 0

      my_land    = 0
      all_id     = 0
      ease_grid_area = 0. 
      tile_area_land = 0.       
      tile_ele       = 0.
      tile_area      = 0.

      ! While looping through the nc x nr grid, this section derives land, ice and water tiles.
      ! Each EASE grid cell is assigned with an ID = ind_row*ND +  ind_col 
      !         ind_col, ind_row are overlying EASE grid cell indices 
      ! Based on the above sums: 
      !         l_index Grid cells have land fractions (sum(land_id)) 
      !         w_index EASE Grid cells have inland water fractions (sum(water_id))
      !         i_index EASE Grid cells have ice fractions (sum(ice_id))
      ! hence, tile_index        1                     to l_index                     represent land tiles  
      !         tile_index       l_index +1            to l_index + w_index           represent water (lakes) tiles  
      !         tile_index       l_index + w_index +1  to l_index + w_index + i_index represent ice tiles
      ! global nc x nr array of tileid_index(nc,nr) contains corresponding tile_index values which 
      !        is derived in the below loop
 
      ND_raster = 10*10**(nint(log10(1.*NR)))
      i2 = 1

      do i = 1 ,nc
         
         clon = -180. + float(i-1)*dx + dx/2.
         
         do j =nr ,1 ,-1
            lats = -90._8 + (j - 0.5_8)*dy
            clat = -90. + float(j-1)*dy + dy/2.
            call EASE_convert(EASELabel, clat, clon, r_ease, s_ease)
            
            ind_col = nint(r_ease) + 1 
            ind_row = nint(s_ease) + 1

            l=  ind_row*ND +  ind_col
            pix_area =(sin(d2r*(lats+0.5*dy)) -sin(d2r*(lats-0.5*dy)))*(dx*d2r)

            if((ind_row.ge.1).and.(veg(i,j).ge.1).and.(ind_row.le.nr_ease)) then
                                           
               if(veg(i,j)==LakeType) then
                  if(water_id(l)==0) then
                     w_index = w_index + 1
                     water_id(l) = w_index  
                     tileid_index(i,j)= water_id(l)
                  else
                     tileid_index(i,j)= water_id(l)
                  endif
               endif
               
               if(veg(i,j)==IceType) then
                  if(ice_id(l)==0) then
                     i_index = i_index + 1
                     ice_id  (l) = i_index
                     tileid_index(i,j)= ice_id  (l)  !i_index
                  else
                     tileid_index(i,j)= ice_id  (l)  !i_index
                  endif
               endif
               
               if(veg(i,j).lt.LakeType) then
                  if(land_id(l)==0) then
                     l_index = l_index + 1     
                     land_id (l) = l_index        
                     tileid_index(i,j)= land_id (l) !1-l_index
                  else
                     tileid_index(i,j)= land_id (l) !1-l_index
                  endif
 
               endif
               tile_area(tileid_index(i,j))= tile_area(tileid_index(i,j)) + &
                    pix_area     
               my_land(tileid_index(i,j)) = l
               all_id (tileid_index(i,j)) = j*ND_raster + i 
            endif

            if((ind_row.ge.1).and.(ind_row.le.nr_ease)) then  
               ease_grid_area(l) = ease_grid_area(l) +             &
                    pix_area
            endif

            ! computing tile area/elevation
            ! -----------------------------

           if((tileid_index(i,j) > 0).and.(tileid_index(i,j) <= nland_cells))then
               tile_ele(tileid_index(i,j))       = tile_ele(tileid_index(i,j)) + q0(i,j) *  &	
                    pix_area
               tile_area_land(tileid_index(i,j)) = tile_area_land(tileid_index(i,j))     +  &	
                    pix_area
            endif  
         end do
      end do
      
      deallocate(land_id, q0)
      deallocate(water_id)
      deallocate(ice_id  )

      tile_ele = tile_ele/tile_area_land

      ! adjustment Global Mean Topography to 614.649 (615.662 GTOPO 30) m
      ! -----------------------------------------------------------------
      sum1=0.
      sum2=0. 

      do j=1,l_index	 
         sum1 = sum1 + tile_ele(j)*tile_area(j)
      enddo

      if(sum1/sum(tile_area(1:l_index)).ne. 614.649D0 ) then
         print *,'Global Mean Elevation (over land): ', sum1/sum(tile_area(1:l_index))
         tile_ele =tile_ele*(614.649D0 / (sum1/sum(tile_area(1:l_index))))				  	
         sum1=0.
         sum2=0. 
         do j=1,l_index	 
            sum1 = sum1 + tile_ele(j)*tile_area(j)
         enddo
         print *,'Global Mean Elevation after scaling to SRTM : ',sum1/sum(tile_area(1:l_index))
      endif
              print *,'Total Land Area :', sum(tile_area(1:l_index))* MAPL_RADIUS * MAPL_RADIUS/1000./1000., &
                   sum(tile_area_land(1:l_index))* MAPL_RADIUS * MAPL_RADIUS/1000./1000.

      print *,'Creating ... ', trim(gfile)//'.rst'

     !-------------------------------------------

      open (10, file ='rst/'//trim(gfile)//'.rst',form='unformatted',status='unknown',  &
           action='write')
      
      do j=1,nr
         write(10)(tileid_index(i,j),i=1,nc)
      end do
      
      close (10,status='keep')

      print *,'Creating ... ', trim(gfile)//'.til ,catchment.def'
 
    !-----------------------------------------------------------

      open (11,file='clsm/catchment.def',     &
           form='formatted',status='unknown')
      write(11,*)l_index

      open  (10, file ='til/'//trim(gfile)//'.til',form='formatted',status='unknown',action='write')
      write (10,*)i_index,SRTM_maxcat, nc, nr 
      write (10,*)1
      write (10,*)EASELabel
      write (10,*)nc_ease
      write (10,*)nr_ease
 !     write (10,*)'NO-OCEAN'
 !     write (10,*) -9999
 !     write (10,*) -9999      

      do l=1,i_index

         ig    = my_land(l)-ND*(my_land(l)/ND)
         jg    = my_land(l)/ND
  
         cindex= catid_index(all_id(l)-ND_raster*(all_id(l)/ND_raster),all_id(l)/ND_raster)

         if (index(MaskFile,'GEOS5_10arcsec_mask') /= 0) then
            pfaf = cindex
         else
            pfaf = catid(all_id(l)-ND_raster*(all_id(l)/ND_raster),all_id(l)/ND_raster)
         endif

         if ((l > l_index).and.(l <= w_index)) typ =19
         if (l > w_index) typ = 20

         if (l <= l_index) then 
            typ = 100
            call EASE_inverse (EASELabel, real(ig-1),real(jg-1), clat, clon) 
            
            mnx = clon - 180./real(nc_ease)
            mxx = clon + 180./real(nc_ease)
            
            jgv = real(jg-1) + 0.5
            
            call EASE_inverse (EASELabel, real(ig-1),jgv, clat, clon) 

            mny = clat
         
            jgv = real(jg-1) - 0.5
         
            call EASE_inverse (EASELabel, real(ig-1),jgv, clat, clon) 

            mxy = clat 

            write (11,'(i10,i8,5(2x,f9.4), i4)')l,pfaf,mnx,mxx,mny,mxy,tile_ele(l)

         endif

         call EASE_inverse (EASELabel, real(ig-1),  real(jg-1), clat, clon)
         
         fr_gcm= tile_area(l)/ease_grid_area(jg*ND +  ig)

         if (index(MaskFile,'GEOS5_10arcsec_mask') /= 0) then
            write(10,'(i10,i9,2f10.4,2i6,f19.12,i10,i15,e13.4)') &
                 typ,pfaf,clon,clat,ig-1,jg-1,fr_gcm ,pfaf,SRTM_catid(cindex) 
         else
            write(10,'(i10,i9,2f10.4,2i5,f19.12,i10,e13.4,i8)') &
                 typ,pfaf,clon,clat,ig-1,jg-1,fr_gcm ,cindex 
         endif
         
      end do
      
      close (10,status='keep')      
      close (11,status='keep')          

      deallocate (tileid_index,catid_index,veg)
      deallocate (tile_area, ease_grid_area, tile_ele, tile_area_land, my_land, all_id)
 
      if (index(MaskFile,'GEOS5_10arcsec_mask') /= 0) then         

         print *,'Creating SMAP-Catch_TransferData.nc files.'

         !---------------------------------------------------

         deallocate (SRTM_CatchArea, SRTM_catid, SRTM_catid_r8)
         
      endif
      
      ! create Grid2Catch transfer file
      ! -------------------------------

      ! CALL CREATE_ROUT_PARA_FILE (NC, NR, trim(gfile), MGRID=MGRID)  
      
      ! now run mkCatchParam
      ! --------------------

      ! WY Note: now mkCatchParam is run in the make_bcs script, not here
      !          and nthread will be reset to run mkCatchParam

      ! tmpstring1 = '-e EASE -g '//trim(gfile)//' -v '//trim(LBCSV)
      ! write(tmpstring2,'(2(a2,x,i5,x))')'-x',nc,'-y',nr
      ! tmpstring = 'bin/mkCatchParam.x '//trim(tmpstring2)//' '//trim(tmpstring1)
      ! print *,trim(tmpstring)
      
      ! call execute_command_line (tmpstring)


!!! commented out. It may be used in the future for irrigation tiles
!!!    contains
!!!
!!!      ! -------------------------------------------------------------------------------
!!!
!!!      SUBROUTINE mkEASEv2Raster
!!!
!!!        implicit none
!!!
!!!        integer       :: i, j, i_ease, j_ease
!!!        real*8,   allocatable :: xs(:,:), ys(:,:)
!!!        real          :: x,y, xout, yout
!!!        
!!!        allocate (xs ( nc_ease+1, nr_ease+1))
!!!        allocate (ys ( nc_ease+1, nr_ease+1))
!!!        
!!!        do  j = 1, nr_ease+1
!!!           do i = 1, nc_ease+1
!!!              x = real(i-1)        -0.5
!!!              y = real(nr_ease - j)+0.5
!!!              call EASE_inverse(MGRID, x, y, yout, xout)
!!!              ys (i,j) = dble(yout)
!!!              xs (i,j) = dble(xout)
!!!           end do
!!!        end do
!!!
!!!        call  LRRasterize(EASElabel,xs,ys,nc=nc,nr=nr,xmn = xs(1,1), xmx= xs(nc_ease+1, nr_ease+1), &
!!!                       ymn=ys(1,1), ymx = ys(nc_ease+1, nr_ease+1), Here=.false., Verb=.false.)       
!!!
!!!        stop
!!!      end SUBROUTINE mkEASEv2Raster
!!!
!!!      ! ------------------------------------------------------------
!!!      
!!!      SUBROUTINE write_tilfile 
!!!
!!!        implicit none
!!!
!!!        character*200 :: infile
!!!        integer      :: NT, NF, NC, NR, NPF, NG, IDUM, i, N, icol, rcol
!!!        character*20 :: cdum
!!!        integer, dimension (:,:), allocatable :: iRtable
!!!        real,    dimension (:,:), allocatable :: rRtable
!!!
!!!        infile = 'til/'//trim(EASElabel)//'_'//trim(EASElabel)//'-Pfafstetter.'
!!!        
!!!        open (10,file =  trim(infile)//'ind', form = 'formatted', action = 'read', status = 'old')
!!!        open (11,file =  trim(infile)//'TIL', form = 'formatted', action = 'write', status = 'unknown')
!!!
!!!        read (10, *) NT, NF, NC, NR
!!!        write (11,'(4I10)')NT, NF, NC, NR
!!!        read (10, *) NG
!!!        write(11, *) NG
!!!        
!!!        do n = 1, NG
!!!           read (10, '(a)') cdum
!!!           write(11, '(a)') trim (cdum)
!!!           read (10, *) IDUM
!!!           write(11, '(I10)') IDUM
!!!           read (10, *) IDUM
!!!           write(11, '(I10)') IDUM
!!!        end do
!!!        
!!!        icol = 7
!!!        rcol = 5
!!!        allocate (iRtable (1, 1:icol))
!!!        allocate (rRtable (1, 1:rcol))
!!!        
!!!        do n = 1,  nt
!!!           read(10,'(I10,3E20.12,9(2I10,E20.12,I10))') iRtable (1,1),rRtable(1,1), &
!!!                rRtable(1,2),rRtable(1,3),iRtable (1,2),iRtable (1,3),rRtable(1,4),iRtable (1,4),&
!!!                iRtable (1,5),iRtable (1,6),rRtable(1,5),iRtable (1,7)
!!!           write(11,'(I10,3E20.12,9(2I10,E20.12,I10))') iRtable (1,1),rRtable(1,1), &
!!!                rRtable(1,2),rRtable(1,3),iRtable (1,2)-1,nr_ease - iRtable (1,3),rRtable(1,4),iRtable (1,4),&
!!!                iRtable (1,5),iRtable (1,6),rRtable(1,5),iRtable (1,7)
!!!        end do
!!!     
!!!        close (10, status = 'keep')
!!!        close (11, status = 'keep')
!!!    
!!!   END SUBROUTINE write_tilfile
 END PROGRAM

